package cmsc433.p2;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import cmsc433.p2.Machine.MachineType;
import cmsc433.p2.SimulationEvent;


/**
 * Validates a simulation
 */
public class Validate {
	private static class InvalidSimulationException extends Exception {
		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check, String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events in a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
		// ALL CREDIT TO: Will Kunkel
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with initiation event");
			check(events.get(events.size()-1).event == 
					SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with termination event");

			int numCustomers = events.get(0).simParams[0];
			int numCooks = events.get(0).simParams[1];
			int numTables = events.get(0).simParams[2];
			int capacity = events.get(0).simParams[3];
			
			int fryerCount = 0;
			int ovenCount = 0;
			int grillPressCount = 0;
			int fountainCount = 0;
			int customerCount = 0;
			HashMap<Cook, Integer> busyCooks = new HashMap<Cook, Integer>();
			HashMap<Integer, List<Food>> orderToFood = new HashMap<Integer, List<Food>>();
			HashMap<Integer, List<Food>> orderToStartedFood = new HashMap<Integer, List<Food>>();
			HashMap<Integer, List<Food>> orderToFinishedFood = new HashMap<Integer, List<Food>>();
			HashSet<Customer> customersInside = new HashSet<Customer>();
			HashSet<Customer> customersWaiting = new HashSet<Customer>();
			HashSet<Customer> customersServed = new HashSet<Customer>();
			HashSet<Integer> ordersPlaced = new HashSet<Integer>();
			HashSet<Integer> ordersCompleted = new HashSet<Integer>();
			for (SimulationEvent event : events) {
				switch (event.event) {
				case MachineStartingFood:
					switch (event.machine.machineType) {
					case fountain:
						fountainCount++;
						break;
					case fryer:
						fryerCount++;
						break;
					case grillPress:
						grillPressCount++;
						break;
					case oven:
						ovenCount++;
						break;
					default:
						break;
					}
					break;
				case MachineDoneFood:
					switch (event.machine.machineType) {
					case fountain:
						fountainCount--;
						break;
					case fryer:
						fryerCount--;
						break;
					case grillPress:
						grillPressCount--;
						break;
					case oven:
						ovenCount--;
						break;
					default:
						break;
					}
					break;
				case CustomerEnteredRatsies:
					customerCount++;
					check(customersInside.add(event.customer), "Customer entered twice");
					break;
				case CustomerLeavingRatsies:
					customerCount--;
					check(customersInside.remove(event.customer), "Customer left without entering");
					check(customersServed.contains(event.customer), "Customer left without being served");
					break;
				case CustomerPlacedOrder:
					check(customersInside.contains(event.customer), "Customer placed order before they were inside");
					check(ordersPlaced.add(event.orderNumber), "Order placed twice");
					check(customersWaiting.add(event.customer), "Customer placed order twice");
					break;
				case CustomerReceivedOrder:
					check(ordersCompleted.contains(event.orderNumber), "Customer recieved order before it was complete");
					check(customersServed.add(event.customer), "Customer recieved order twice");
					break;
				case CookReceivedOrder:
					check(!busyCooks.containsKey(event.cook), "Cook doing two orders at once");
					check(ordersPlaced.contains(event.orderNumber), "Cook got order before it was placed");
					busyCooks.put(event.cook, event.orderNumber);
					orderToFood.put(event.orderNumber, event.orderFood);
					break;
				case CookCompletedOrder:
					check(busyCooks.remove(event.cook) == event.orderNumber, "Cook completed order they never started");
					check(ordersCompleted.add(event.orderNumber), "Order completed twice");
					ArrayList<Food> unfinishedFood = new ArrayList<Food>(orderToFood.get(event.orderNumber));
					if (orderToFinishedFood.containsKey(event.orderNumber)) { 
						for (Food food : orderToFinishedFood.get(event.orderNumber)) {
							unfinishedFood.remove(food);
						}
					}
					check(unfinishedFood.isEmpty(), "Cook completed order before all food was done");
					break;
				case CookStartedFood:
					check(busyCooks.get(event.cook) == event.orderNumber, "Cook started food for an order they never got");
					if (!orderToStartedFood.containsKey(event.orderNumber)) {
						orderToStartedFood.put(event.orderNumber, new ArrayList<Food>());
					}
					ArrayList<Food> foodLeftToStart = new ArrayList<Food>(orderToFood.get(event.orderNumber));
					for (Food food : orderToStartedFood.get(event.orderNumber)) {
						foodLeftToStart.remove(food);
					}
					check(foodLeftToStart.contains(event.food), "Started an item not needed");
					orderToStartedFood.get(event.orderNumber).add(event.food);
					break;
				case CookFinishedFood:
					check(busyCooks.get(event.cook) == event.orderNumber, "Cook finished food for an order they never got");
					if (!orderToFinishedFood.containsKey(event.orderNumber)) {
						orderToFinishedFood.put(event.orderNumber, new ArrayList<Food>());
					}
					ArrayList<Food> foodLeftToFinish = new ArrayList<Food>(orderToStartedFood.get(event.orderNumber));
					for (Food food : orderToFinishedFood.get(event.orderNumber)) {
						foodLeftToFinish.remove(food);
					}
					check(foodLeftToFinish.contains(event.food), "Finished an item not started");
					orderToFinishedFood.get(event.orderNumber).add(event.food);
					break;
				}
				
				check(fountainCount <= capacity, "Fountain overfull");
				check(fryerCount <= capacity, "Fryer overfull");
				check(grillPressCount <= capacity, "Grill press overfull");
				check(ovenCount <= capacity, "Oven overfull");
				check(customerCount <= numTables, "Restaurant overfull");
			}

			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
		

		
	}

	
}

// Author: Ben Aronson
//try {
//	////////// Starting checks ///////////////////////////////////////////////////
//	check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
//			"Simulation didn't start with initiation event");
//	check(events.get(events.size()-1).event == 
//			SimulationEvent.EventType.SimulationEnded,
//			"Simulation didn't end with termination event");
//	//////////////////////////////////////////////////////////////////////////////
//	
//	// Credit to Everest Liu for some inspiration on how to go about this
//	
//	////// Total Simulation variables ///////
//	int[] simParams = events.get(0).simParams;
//	int totCustomers= simParams[0];
//	int totCooks 	= simParams[1];
//	int totTables 	= simParams[2];
//	int machCapac 	= simParams[3];
//	///////////////////////////////////
//	
//	/////// Running number variables - used to check as we go ////////
//	int curCustomers= 0;
//	int curCooks 	= 0;
//	int curTables	= 0;
//	int machStarted = 0;
//	int curOrders	= 0;
//	//////////////////////////////////////////////////////////////////
//	//TODO
//	/////// Running container variables - used to check as we go ////////
//	List<Integer> ordersPlaced = new ArrayList<Integer>();
//	List<Integer> ordersTaken = new ArrayList<Integer>();
//	List<Integer> completedOrders = new ArrayList<Integer>();
//	List<String> customersPlaced = new ArrayList<String>();
//	List<String> customersDone = new ArrayList<String>();
//	HashMap<String, Integer> cooksOrders = new HashMap<String, Integer>();
//	HashMap<String, Integer> machinesCapacity = new HashMap<String, Integer>();
//	/////////////////////////////////////////////////////////////////////
//	
//	
//	/* ************************************************************* */
//	/* ******* Checking methods ************************************ */
//	/* ************************************************************* */
//	
//	
//	/////// Start Machine check ///////////////////////////////////////////
//	// Events 1-4 should always be the machines starting up: Fountain->Fryer->Grill->Oven
//	for(int i = 1; i <= 4; i++) {
//		SimulationEvent machineStartEvent = events.get(i);
//		check(machineStartEvent.event == SimulationEvent.EventType.MachineStarting, 
//				"Event " + i + " was not a Machine starting");
//		
//		if(i==1) {
//			check(machineStartEvent.machine.machineType == MachineType.fountain, "Wrong machine: fountain");
//			machStarted++;
//		}
//		else if(i==2) {
//			check(machineStartEvent.machine.machineType == MachineType.fryer, "Wrong machine: fryer");
//			machStarted++;
//		}
//		else if(i==3) {
//			check(machineStartEvent.machine.machineType == MachineType.grillPress, "Wrong machine: grill press");
//			machStarted++;
//		}
//		else if(i==4) {
//			check(machineStartEvent.machine.machineType == MachineType.oven, "Wrong machine: oven");
//			machStarted++;
//		}
//		else
//			System.out.println("Error in validateSimulation()");
//	}
//	check(machStarted == 4, "Not enough Machines started");
//	//////////////////////////////////////////////////////////////////////
//	
//
//	
//	for(int i=5; i < events.size()-5; i++) {
//		SimulationEvent currentEvent = events.get(i);
//		
//		if(currentEvent.event == SimulationEvent.EventType.CookStarting) {
//			// New Cook starting, make sure there aren't too many
//			curCooks++;
//			check(curCooks <= totCooks, "Too many Cooks");
//		}
//		else if(currentEvent.event == SimulationEvent.EventType.CustomerStarting) {
//			// New Customer starting, make sure there aren' too many
//			curCustomers++;
//			check(curCustomers <= totCustomers, "Too many Customers");
//		}
//		else if(currentEvent.event == SimulationEvent.EventType.CustomerEnteredRatsies) {
//			// Make sure Customer entered Restaurant correctly
//			curTables++;
//			check(curTables <= totTables, "Too many Customers in Ratsies");
//		}
//		else if(currentEvent.event == SimulationEvent.EventType.CustomerLeavingRatsies) {
//			// Update when Customer leaves -- the check here should really never fire
//			curTables--;
//			check(curTables >= 0, "Somehow there are negative tables");
//		}
//		else if(currentEvent.event == SimulationEvent.EventType.CustomerPlacedOrder) {
//			// Check for Customer entering Order correctly i.e. hasn't placed
//			curOrders++;
//			check(curOrders <= totCustomers, "Too many orders placed");
//			
//			check(ordersPlaced.contains(currentEvent.orderNumber), "Order has already been placed");
//			ordersPlaced.add(currentEvent.orderNumber);
//			customersPlaced.add(currentEvent.customer.toString());
//		}
//		else if(currentEvent.event == SimulationEvent.EventType.CookReceivedOrder) {
//			// Check: Cook doesn't already have an Order, Order hasn't already been taken, Order has been placed
//			check(ordersPlaced.contains(currentEvent.orderNumber), "Cook trying to get Order that hasn't been placed");
//			check(ordersTaken.contains(currentEvent.orderNumber), "Cook trying to get Order that has already been taken");
//			check(cooksOrders.containsKey(currentEvent.cook.toString()), "Cook already has an Order");
//			ordersTaken.add(currentEvent.orderNumber);
//			cooksOrders.put(currentEvent.cook.toString(), currentEvent.orderNumber);
//		}
//		else if(currentEvent.event == SimulationEvent.EventType.CookStartedFood) {
//			// Check that the machine is not over capacity, Cook isn't already busy, Order hasn't been placed
//			check(ordersPlaced.contains(currentEvent.orderNumber), "Cook trying to start food but order hasn't been placed");
//			
//		}
//		
//	}
//	//TODO
//	
//	
//	
//	
///* In P2 you will write validation code for things such as:
//	Should not have more eaters than specified
//	Should not have more cooks than specified
//	The Ratsie's capacity should not be exceeded
//	The capacity of each machine should not be exceeded
//	Eater should not receive order until cook completes it
//	Eater should not leave Ratsie's until order is received
//	Eater should not place more than one order
//	Cook should not work on order before it is placed
// */
//	
//	
//	
//	/////// End Machine check ///////////////////////////////////////////
//	// events.size()-5 through events.size()-2 should always be the machines ending: 
//	//	Fountain->Fryer->Grill->Oven
//	int startMachineEnd = events.size()-5;
//	for(int i = startMachineEnd; i <= events.size()-2; i++) {
//		SimulationEvent machineEndEvent = events.get(i);
//		check(machineEndEvent.event == SimulationEvent.EventType.MachineEnding, 
//				"Event " + i + " was not a Machine ending");
//		
//		if(i==startMachineEnd) 
//			check(machineEndEvent.machine.machineType == MachineType.fountain, "Wrong machine: fountain");
//			// check for correct Food
//		else if(i==startMachineEnd+1) 
//			check(machineEndEvent.machine.machineType == MachineType.fryer, "Wrong machine: fryer");
//		else if(i==startMachineEnd+2)  
//			check(machineEndEvent.machine.machineType == MachineType.grillPress, "Wrong machine: grill press");
//		else if(i==startMachineEnd+3)
//			check(machineEndEvent.machine.machineType == MachineType.oven, "Wrong machine: oven");
//		else
//			System.out.println("Error in validateSimulation() - Machine End");
//	}
//	//////////////////////////////////////////////////////////////////////
//	
//	
//
//
//
//	return true;
//} catch (InvalidSimulationException e) {
//	return false;
//}



















// Credit: Everest Liu
//try {
//	int[] simParams = events.get(0).simParams;
//	
//	int customerCount = 0;
//	int cookCount = 0;
//	int tableCount = 0;
//	
//	int fryerCount = 0;
//	int ovenCount = 0;
//	int grillCount = 0;
//	int fountainCount = 0;
//	
//	ArrayList<Integer> orders = new ArrayList<Integer>();
//	ArrayList<Integer> completedOrders = new ArrayList<Integer>();
//	
//	ArrayList<String> placedOrderCustomers = new ArrayList<String>();
//	ArrayList<String> receivedCustomers = new ArrayList<String>();
//	
//	check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
//			"Simulation didn't start with initiation event.");
//	check(events.get(events.size()-1).event == 
//			SimulationEvent.EventType.SimulationEnded,
//			"Simulation didn't end with termination event.");
//
//	/* In P2 you will write validation code for things such as:
//		Should not have more eaters than specified
//		Should not have more cooks than specified
//		The Ratsie's capacity should not be exceeded
//		The capacity of each machine should not be exceeded
//		Eater should not receive order until cook completes it
//		Eater should not leave Ratsie's until order is received
//		Eater should not place more than one order
//		Cook should not work on order before it is placed
//	 */
//	
//	
//	for (int i = 0; i < events.size(); i++) {
//		if (events.get(i).event == SimulationEvent.EventType.CustomerStarting) {
//			customerCount++;
//			check(customerCount <= simParams[0], "Customer size has been exceeded.");
//		} else if (events.get(i).event == SimulationEvent.EventType.CookStarting) {
//			cookCount++;
//			check(cookCount <= simParams[1], "Cook size has been exceeded.");
//		} else if (events.get(i).event == SimulationEvent.EventType.CustomerEnteredRatsies) {
//			tableCount++;
//			check(tableCount <= simParams[2], "Too many customers in Ratsie's.");
//		} else if (events.get(i).event == SimulationEvent.EventType.CustomerLeavingRatsies) {
//			tableCount--;
//		} else if (events.get(i).event == SimulationEvent.EventType.MachineStartingFood) {
//			if (events.get(i).food == FoodType.wings) {
//				fryerCount++;
//				check(fryerCount <= simParams[3], "Fryer capacity exceeded.");
//			} else if (events.get(i).food == FoodType.pizza) {
//				ovenCount++;
//				check(ovenCount <= simParams[3], "Oven capacity exceeded.");
//			} else if (events.get(i).food == FoodType.sub) {
//				grillCount++;
//				check(grillCount <= simParams[3], "Grill capacity exceeded.");
//			} else if (events.get(i).food == FoodType.soda) {
//				fountainCount++;
//				check(fountainCount <= simParams[3], "Fountain capacity exceeded.");
//			}
//		} else if (events.get(i).event == SimulationEvent.EventType.MachineDoneFood) {
//			if (events.get(i).food == FoodType.wings) {
//				fryerCount--;
//			} else if (events.get(i).food == FoodType.pizza) {
//				ovenCount--;
//			} else if (events.get(i).food == FoodType.sub) {
//				grillCount--;
//			} else if (events.get(i).food == FoodType.soda) {
//				fountainCount--;
//			}
//		} else if (events.get(i).event == SimulationEvent.EventType.CustomerPlacedOrder) {
//			check(!placedOrderCustomers.contains(events.get(i).customer.toString()), "Customer already ordered.");
//			orders.add(events.get(i).orderNumber);
//			placedOrderCustomers.add(events.get(i).customer.toString());
//		} else if (events.get(i).event == SimulationEvent.EventType.CookCompletedOrder) {
//			completedOrders.add(events.get(i).orderNumber);
//			orders.remove(new Integer(events.get(i).orderNumber));
//		} else if (events.get(i).event == SimulationEvent.EventType.CustomerReceivedOrder) {
//			check(completedOrders.contains(events.get(i).orderNumber), "Cook has not completed order.");
//			completedOrders.remove(new Integer(events.get(i).orderNumber));
//			receivedCustomers.add(events.get(i).customer.toString());
//		} else if (events.get(i).event == SimulationEvent.EventType.CustomerLeavingRatsies) {
//			check(receivedCustomers.contains(events.get(i).customer.toString()), "Customer has not received order yet.");
//		} else if (events.get(i).event == SimulationEvent.EventType.CookStartedFood) {
//			check(orders.contains(events.get(i).orderNumber), "Order has not been placed yet.");
//		}
//	}
//
//	return true;
//} catch (InvalidSimulationException e) {
//	return false;
//}
